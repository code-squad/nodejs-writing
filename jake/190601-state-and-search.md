z탐색을 사전에서 찾아보면 찾을 탐(探) 자에 찾을 색(索)을 사용하는 단어로, 두 한자 모두 '더듬어 찾다'를 뜻하고 있습니다. 여기서 '**더듬다**'라는 표현에 주목해야 합니다. 어두컴컴한 방이나 침대 밑에 떨어진 물건을 찾을 때, 불을 켜지 않는 이상 손으로 바닥을 더듬으면서 찾게 될 겁니다. 시간상으로는 비효율적이지만 가장 기초적인 탐색 방법이죠. 하지만 컴퓨터에게 탐색을 시킬 때는 이야기가 달라집니다. 컴퓨터의 연산 속도는 엄청나게 빨라서 사람이 직접하는 것 보다 훨신 빠르게 결과를 보여줄 겁니다. 그런데 어떻게 컴퓨터로 '**더듬어 찾다**'라는 행동을 구현할 수 있을까요? 이걸 구현하려면 우선 상태라는 개념을 알고 있어야 합니다.

## 상태

**상태(state)**는 탐색 알고리즘을 실행하면서 변화하는 각 상황을 나타낸다고 볼 수 있습니다. 그리고 어떤 문제에서 표현할 수 있는 모든 상태의 집합을 **상태 공간(state space)**이라고 합니다. 따라서 탐색을 한다는 것은 초기 상태에서 출발해 상태 공간을 **더듬어가며** 목표로 하는 상태를 찾는 것이라고 할 수 있습니다. 

[16 숫자 퍼즐](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FbvDFFZ%2FbtqvTGxlehv%2FGn4cVwNvAq2Vz2dxAubNX0%2Fimg.jpg)

문구점에서 팔던 숫자 퍼즐 게임기를 떠올려봅시다. 이 퍼즐의 특징은 1부터 16이 아닌 15까지의 숫자가 각인된 블록이 존재하고 16은 존재하지 않고 비어있는 모습이 된다는 것입니다. 그리고 퍼즐의 목표는 가능한 빨리 모든 숫자 블록을 순서대로 정렬하는 것입니다.

이 숫자 퍼즐의 상태를 코드로 나타내려면 4x4 배열을 사용해서 각 위치에 맞게 숫자를 넣어주고 비어있는 부분은 0으로 나타내면 됩니다.

## 탐색

상태를 코드로 나타냈으니 이제 탐색을 할 차롑니다. 이번에도 예시를 보여주고 설명하겠습니다. 아래 그림은 임의로 생성된 퍼즐입니다.


[16 퍼즐 예시](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FbnLFJb%2FbtqvTfGNrOu%2FB7RgCOwKTMqozPqcsym9P1%2Fimg.png)

앞서 설명했듯이 비어있는 부분은 0으로 나타냈습니다. 탐색은 상태를 변경시키는 알고리즘이라고 할 수 있으니 어떻게 상태를 변경시킬지부터 생각해봅시다. 실제로 16 퍼즐 장난감을 다룰 떈 비어있는 칸을 기준으로 상하좌우에 있는 블록 중 하나를 비어있는 위치로 옮겨 퍼즐을 풀어나갈 겁니다. 이를 코드로 구현하면 0과 상하좌우에 있는 숫자 중 하나를 바꿔주면 되겠죠. 이를 그림으로 표현하면 다음과 같습니다.

[16 퍼즐 BFS 풀이](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FbICaRs%2Fbtqv8njBUJe%2F1u9hUk9qukchuAMjtCb1yk%2Fimg.png)

비어있는 칸을 기준으로 상하좌우에 존재하는 블록이 총 4개이므로 경우의 수도 4가지가 됩니다. 이렇게 초기 상태에서 파생된 새로운 상태마다 앞서 정의한 연산을 실행하다 보면 언젠가 목표 상태에 도달하게 될 겁니다.

위와 같은 그림은 전형적인 트리 구조임을 눈치채셨을 겁니다. 그렇다면 부모 노드와 자식 노드 간의 링크는 연산 한 번을 실행했다는 의미가 되겠죠. 이렇게 같은 레벨에 존재하는 모든 상태에 상태를 바꾸는 연산을 실행해주고 다음 레벨로 넘어가서 같은 행동을 반복하면, 그리고 목표 상태에 도달했을 때 초기 상태까지의 길이를 구하면 16 퍼즐을 푸는 최소 연산 횟수를 구할 수 있습니다.

이렇게 트리에서 같은 레벨에 존재하는 모든 노드에 연산을 적용하고 다음 레벨로 넘어가서 같은 행동을 반복하는 알고리즘을 **BFS**라고 부릅니다. BFS는 뒤에서 설명할 **DFS**와 같이 모든 경우의 수를 탐색하는 **완전 탐색**의 일종입니다. 따라서 탐색 알고리즘으로 BFS를 사용한다면 앞서 언급했던 '**더듬어 찾기**'를 컴퓨터에 명령할 수 있게 되는 것입니다.

### DFS

[BFS와 DFS](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2FSfxCD%2FbtqwebD3eJA%2F3ok34bSM8XLWy3CbkGqpJk%2Fimg.png)

BFS는 최솟값을 구하는 문제에 적합한 탐색 방법입니다. 반면 DFS는 트리의 한 줄기를 따라 계속 내려가기 때문에 최솟값을 구하는 문제에는 적합하지 않습니다(물론 최솟값을 구할 수는 있습니다). 그 대신 DFS는 BFS에서는 얻을 수 없는 이점이 있기 때문에(특히 메모리 측면에서) 많이 사용하는 방법입니다. 예시로 들어가기에 앞서 **백트래킹**이라는 것을 알아봅시다.

#### 백트래킹

DFS는 재귀를 사용해서 구현하는 것이 일반적입니다. 재귀를 사용하면 기저 사례(base case, 재귀를 종료하는 조건)를 만날 때까지 새로운 함수를 계속 호출하게 됩니다. 그러다가 기저 사례를 만나고 값을 반환하거나 함수의 return 문을 실행하면 현재 실행한 함수를 콜 스택(call stack)에서 제거하고 바로 이전에 호출했던 함수로 돌아가게 됩니다. 이런 행동을 반복하면 결국 처음에 재귀 함수를 호출했던 위치로 돌아가게 됩니다. 이렇게 이전에 호출했던 함수로 다시 거슬러 올라가는 것을 **백트래킹**이라고 합니다.

프로세스의 메모리 레이아웃은 크게 텍스트 영역, 데이터 영역, 힙 영역, 그리고 스택 영역으로 나뉩니다. 그중 스택 영역은 함수의 파라미터와 지역 변수 등이 저장됩니다. 재귀 함수를 사용하게 되면 콜 스택에 남아있는 재귀 함수는 값을 반환하기 전까지는 함수의 파라미터와 지역 변수가 그대로 남아있게 됩니다. 따라서 백트래킹으로 이전에 호출했던 함수로 돌아가게 되면 이 변수들을 다시 사용할 수 있습니다.

#### 예시

DFS를 쓰기 좋은 문제 중의 하나는 바로 스도쿠입니다.

일반적인 스도쿠의 규칙은 다음과 같습니다.

> 1.  각각의 가로줄과 세로줄에는 1부터 9까지의 숫자가 한 번씩만 나타나야 한다.
> 2.  굵은 선으로 구분되어 있는 3x3 정사각형 안에도 1부터 9까지의 숫자가 한 번씩만 나타나야 한다.
> 
> [백준-스도쿠](https://www.acmicpc.net/problem/2580)

스도쿠의 상태를 코드로 표현하는 것은 쉽습니다. $9\\times9$ 배열을 선언하고, 각 위치에 숫자를 넣어주면서 빈 칸은 0으로 표현하면 됩니다. 하지만 이 문제를 BFS로 구현하게 되면 큐에 노드를 집어넣을 때 마다 상태를 표현하는 $9\\times9$ 배열이 포함되어야 합니다. 스도쿠의 빈칸이 $n$개라면 시도해볼 수 있는 경우의 수가 $9^n$개가 됩니다. 상태를 표현하는 데만 $4\\times9^{n+2}$바이트(32비트 정수 기준)가 필요해지는 셈입니다. 조건에 맞지 않는 상태에서 탐색을 진행하지 않도록 코딩하면 메모리 사용량을 줄일 수 있긴 하지만 $n$에 따라서 문제에서 제시하는 메모리의 한도를 초과할 수도 있습니다. 

DFS를 사용하면 상태를 나타내는 $9\\times9$ 배열 하나만 있어도 됩니다. 코드를 작성할 때 재귀적으로 함수를 호출하는 코드 부분의 윗 부분에는 상태를 바꾸는 코드를 쓰고, 아랫 부분에는 원래 상태로 돌아가는 코드를 작성하면 됩니다. 코드로 나타내면 다음과 같습니다.

```
int board[9][9], answer[9][9];

void dfs(int y, int x)
{
  /* 
  * is_invalid_state는 현재 상태가 스도쿠 룰을 어겼는지 확인하고 
  * 어겼다면 true를 반환하는 함수라고 가정합니다.
  * 현재 상태가 스도쿠 룰을 어겼다면 탐색을 종료합니다.
  */
  if(is_invalid_state()) return ; 

  int next_y = -1, next_x = -1;
  set_next(&next_y, &next_x); // 숫자를 채워 넣을 다음 위치를 찾습니다.

  // 다음 위치가 결정되지 않았다는 것은 빈 칸을 모두 채워넣은 상태라는 의미가 됩니다.
  if(next_y == -1) set_answer();

  for(int i=1; i<10; ++i){
    board[y][x] = i; // 상태를 갱신합니다.
    dfs(next_y, next_x);
    board[y][x] = 0; // 탐색을 마치면 원래 상태로 돌아옵니다.
  }
}
```

## 마무리

상태와 탐색의 정의를 알아보고 완전 탐색의 대표적인 알고리즘인 DFS와 BFS를 소개해봤습니다. 사람한텐 쉬운 '더듬어서 찾기'를 컴퓨터로 구현해서 빠른 연산속도를 이용해 어려운 문제도 단순한(?) 방법으로 풀 수 있었음을 알 수 있었습니다. 하지만 상태 공간이 너무나 큰 문제(체스, 바둑 등)에서 DFS와 BFS를 사용하면 원하는 시간 내에 답을 찾지 못할 수도 있고, 어쩌면 영원히 찾을 수 없을 수도 있습니다. 더 효율적인 탐색을 하기 위해서 사용하는 방법에는 휴리스틱 탐색이 있습니다. 관심이 있는 분은 휴리스틱을 공부해보시고, 더 나아가 알파고는 어떻게 상태 공간을 줄였는지 살펴보시면 좋을 것 같습니다. 

## 참고한 자료

[16-숫자 퍼즐 사진](%5Bhttp://www.hanamg.com/mobile/m_goods_detail.php?ps_ctid=14160200&ps_goid=25274%5D(http://www.hanamg.com/mobile/m_goods_detail.php?ps_ctid=14160200&ps_goid=25274))

[BFS와 DFS 비교 사진](http://mishadoff.com/blog/dfs-on-binary-tree-array/)